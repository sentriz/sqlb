package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"unicode"
)

func main() {
	dest := flag.String("to", "", "output file (required)")
	var generated stringsFlag
	flag.Var(&generated, "generated", "generated/auto-increment column to skip on insert/update (repeatable)")
	flag.Parse()

	if *dest == "" || flag.NArg() != 1 {
		fmt.Fprintln(os.Stderr, "usage: sqlbgen -to output.gen.go [-generated column]... TypeName")
		os.Exit(1)
	}

	typeName := flag.Arg(0)

	goFile := os.Getenv("GOFILE")
	if goFile == "" {
		fmt.Fprintln(os.Stderr, "need GOFILE")
		os.Exit(1)
	}
	goPackage := os.Getenv("GOPACKAGE")
	if goPackage == "" {
		fmt.Fprintln(os.Stderr, "need GOPACKAGE")
		os.Exit(1)
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, goFile, nil, parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "parse file: %v\n", err)
		os.Exit(1)
	}

	var fields []string
	for n := range ast.Preorder(node) {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok || typeSpec.Name.Name != typeName {
			continue
		}
		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			continue
		}
		for _, field := range structType.Fields.List {
			for _, name := range field.Names {
				fields = append(fields, name.Name)
			}
		}
		break
	}

	destf, err := os.Create(*dest)
	if err != nil {
		fmt.Fprintf(os.Stderr, "create dest file: %v\n", err)
		os.Exit(1)
	}
	defer destf.Close()

	fmt.Fprintf(destf, "// Code generated by \"%s %s\"; DO NOT EDIT.\n", filepath.Base(os.Args[0]), strings.Join(os.Args[1:], " "))
	fmt.Fprintf(destf, "\n")
	fmt.Fprintf(destf, "package %s\n", goPackage)
	fmt.Fprintf(destf, "\n")
	fmt.Fprintf(destf, "import (\n")
	fmt.Fprintf(destf, "\t\"database/sql\"\n")
	fmt.Fprintf(destf, "\t\"fmt\"\n")
	fmt.Fprintf(destf, ")\n")

	firstChar := strings.ToLower(string([]rune(typeName)[0]))

	fmt.Fprintf(destf, "\nfunc _() {\n")
	fmt.Fprintf(destf, "\t// Validate the struct fields haven't changed. If this doesn't compile you probably need to `go generate` again.\n")
	fmt.Fprintf(destf, "\tvar %s %s\n", firstChar, typeName)
	var fieldRefs []string
	for _, field := range fields {
		fieldRefs = append(fieldRefs, fmt.Sprintf("%s.%s", firstChar, field))
	}
	fmt.Fprintf(destf, "\t_ = %s{%s}\n", typeName, strings.Join(fieldRefs, ", "))
	fmt.Fprintf(destf, "}\n")

	if len(generated) > 0 {
		var cases []string
		for _, col := range generated {
			cases = append(cases, fmt.Sprintf("%q", col))
		}
		caseStr := strings.Join(cases, ", ")

		fmt.Fprintf(destf, "\nfunc (%s) IsGenerated(c string) bool {\n", typeName)
		fmt.Fprintf(destf, "\tswitch c {\n")
		fmt.Fprintf(destf, "\tcase %s:\n", caseStr)
		fmt.Fprintf(destf, "\t\treturn true\n")
		fmt.Fprintf(destf, "\t}\n")
		fmt.Fprintf(destf, "\treturn false\n")
		fmt.Fprintf(destf, "}\n")
	}

	fmt.Fprintf(destf, "\nfunc (%s %s) Values() []sql.NamedArg {\n", firstChar, typeName)
	var namedArgs []string
	for _, f := range fields {
		namedArgs = append(namedArgs, fmt.Sprintf("sql.Named(\"%s\", %s.%s)", toSnake(f), firstChar, f))
	}
	fmt.Fprintf(destf, "\treturn []sql.NamedArg{%s}\n", strings.Join(namedArgs, ", "))
	fmt.Fprintf(destf, "}\n")

	fmt.Fprintf(destf, "\nfunc (%s *%s) ScanFrom(rows *sql.Rows) error {\n", firstChar, typeName)
	fmt.Fprintf(destf, "\tcolumns, err := rows.Columns()\n")
	fmt.Fprintf(destf, "\tif err != nil {\n")
	fmt.Fprintf(destf, "\t\treturn err\n")
	fmt.Fprintf(destf, "\t}\n")
	fmt.Fprintf(destf, "\tdests := make([]any, 0, len(columns))\n")
	fmt.Fprintf(destf, "\tfor _, c := range columns {\n")
	fmt.Fprintf(destf, "\t\tswitch c {\n")
	for _, f := range fields {
		fmt.Fprintf(destf, "\t\tcase \"%s\":\n", toSnake(f))
		fmt.Fprintf(destf, "\t\t\tdests = append(dests, &%s.%s)\n", firstChar, f)
	}
	fmt.Fprintf(destf, "\t\tdefault:\n")
	fmt.Fprintf(destf, "\t\t\treturn fmt.Errorf(\"unknown column name %%q\", c)\n")
	fmt.Fprintf(destf, "\t\t}\n")
	fmt.Fprintf(destf, "\t}\n")
	fmt.Fprintf(destf, "\treturn rows.Scan(dests...)\n")
	fmt.Fprintf(destf, "}\n")
}

func toSnake(s string) string {
	var result strings.Builder
	runes := []rune(s)
	for i, char := range runes {
		if i > 0 && unicode.IsUpper(char) {
			prev := runes[i-1]
			if unicode.IsLower(prev) || unicode.IsDigit(prev) || (i+1 < len(runes) && unicode.IsLower(runes[i+1])) {
				result.WriteRune('_')
			}
		}
		result.WriteRune(unicode.ToLower(char))
	}
	return result.String()
}

type stringsFlag []string

func (s stringsFlag) String() string { return strings.Join(s, ", ") }
func (s *stringsFlag) Set(v string) error {
	*s = append(*s, v)
	return nil
}
